#!/usr/bin/env bash
set -euo pipefail

# Usage: worktree <name>
# Creates a git worktree in a temp directory, spawns tmux, cleans up on exit

BRANCH_NAME=""
WORKTREE_PATH=""
TEMP_DIR=""
CLEANUP_DONE=false
ATTACH_MODE=false

cleanup() {
    # Prevent double cleanup
    if [[ "$CLEANUP_DONE" == "true" ]]; then return; fi
    CLEANUP_DONE=true

    # Only cleanup if paths are set
    if [[ -z "$WORKTREE_PATH" ]]; then return; fi


    # Check if worktree still exists
    if [[ ! -d "$WORKTREE_PATH" ]]; then
        rmdir "$TEMP_DIR" 2>/dev/null || true
        return
    fi

    echo ""
    echo -n "Delete worktree '$BRANCH_NAME'? [y/N] "
    read response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        git worktree remove --force "$WORKTREE_PATH" 2>/dev/null || true
        rmdir "$TEMP_DIR" 2>/dev/null || true
        echo "Worktree removed (branch '$BRANCH_NAME' kept)."
    else
        echo "Worktree kept at: $WORKTREE_PATH"
    fi
}

# 1. Argument validation
if [[ -z "${1:-}" ]]; then
    echo "Usage: worktree <name>"
    exit 1
fi

BRANCH_NAME="$1"

# 2. Git repo validation
if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Error: Not inside a git repository"
    exit 1
fi

# 3. Check if branch already exists and has a worktree
EXISTING_WORKTREE=""
ATTACH_MODE=false

if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
    # Branch exists, check if it has an associated worktree
    EXISTING_WORKTREE=$(git worktree list --porcelain | \
        awk -v branch="$BRANCH_NAME" '
            /^worktree / { path=substr($0, 10) }
            $0 == ("branch refs/heads/" branch) { print path }
        ')

    if [[ -n "$EXISTING_WORKTREE" ]]; then
        echo "Attaching to existing worktree for branch '$BRANCH_NAME'..."
        WORKTREE_PATH="$EXISTING_WORKTREE"
        ATTACH_MODE=true
    else
        echo "Branch '$BRANCH_NAME' exists, creating worktree..."
        ATTACH_MODE=true
    fi
fi

# 4. Setup trap for cleanup (EXIT, INT, TERM)
trap cleanup EXIT INT TERM

# 5. Create worktree if needed
if [[ -z "$WORKTREE_PATH" ]]; then
    TEMP_DIR=$(mktemp -d)
    WORKTREE_PATH="$TEMP_DIR/$BRANCH_NAME"

    if [[ "$ATTACH_MODE" == "true" ]]; then
        # Branch exists, create worktree for existing branch
        if ! git worktree add "$WORKTREE_PATH" "$BRANCH_NAME"; then
            echo "Error: Failed to create worktree"
            rmdir "$TEMP_DIR" 2>/dev/null || true
            WORKTREE_PATH=""  # Prevent cleanup from running
            exit 1
        fi
    else
        # Create new branch with worktree
        if ! git worktree add "$WORKTREE_PATH" -b "$BRANCH_NAME"; then
            echo "Error: Failed to create worktree"
            git branch -D "$BRANCH_NAME" 2>/dev/null || true
            rmdir "$TEMP_DIR" 2>/dev/null || true
            WORKTREE_PATH=""  # Prevent cleanup from running
            exit 1
        fi
    fi
fi

# 6. Spawn tmux
SESSION_NAME="worktree-$BRANCH_NAME-$$"

if [[ -n "${TMUX:-}" ]]; then
    # Already in tmux - create new window in current session
    # Save current window for returning later
    ORIGINAL_WINDOW=$(tmux display-message -p '#{window_id}')
    WAIT_CHANNEL="worktree-done-$$"

    # Create window that signals when shell exits
    tmux new-window -n "$BRANCH_NAME" -c "$WORKTREE_PATH" \
        "\$SHELL; tmux wait-for -S $WAIT_CHANNEL"

    # Wait for signal
    tmux wait-for "$WAIT_CHANNEL"

    # Return to original window for cleanup prompt
    tmux select-window -t "$ORIGINAL_WINDOW"
else
    # Not in tmux, create new session (blocking)
    tmux new-session -s "$SESSION_NAME" -c "$WORKTREE_PATH"
fi

# Cleanup runs via trap on EXIT
