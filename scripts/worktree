#!/usr/bin/env bash
set -euo pipefail

# Usage: worktree <name>
# Creates a git worktree in a temp directory, spawns tmux, cleans up on exit

BRANCH_NAME=""
WORKTREE_PATH=""
TEMP_DIR=""
CLEANUP_DONE=false

cleanup() {
    # Prevent double cleanup
    if [[ "$CLEANUP_DONE" == "true" ]]; then return; fi
    CLEANUP_DONE=true

    # Only cleanup if paths are set
    if [[ -z "$WORKTREE_PATH" ]]; then return; fi

    # Check if worktree still exists
    if [[ ! -d "$WORKTREE_PATH" ]]; then
        rmdir "$TEMP_DIR" 2>/dev/null || true
        return
    fi

    echo ""
    echo -n "Delete worktree and branch '$BRANCH_NAME'? [y/N] "
    read response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        git worktree remove --force "$WORKTREE_PATH" 2>/dev/null || true
        git branch -D "$BRANCH_NAME" 2>/dev/null || true
        rmdir "$TEMP_DIR" 2>/dev/null || true
        echo "Worktree and branch removed."
    else
        echo "Worktree kept at: $WORKTREE_PATH"
    fi
}

# 1. Argument validation
if [[ -z "${1:-}" ]]; then
    echo "Usage: worktree <name>"
    exit 1
fi

BRANCH_NAME="$1"

# 2. Git repo validation
if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Error: Not inside a git repository"
    exit 1
fi

# 3. Check if branch already exists
if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
    echo "Error: Branch '$BRANCH_NAME' already exists"
    exit 1
fi

# 4. Setup trap for cleanup (EXIT, INT, TERM)
trap cleanup EXIT INT TERM

# 5. Create temp directory and worktree
TEMP_DIR=$(mktemp -d)
WORKTREE_PATH="$TEMP_DIR/$BRANCH_NAME"

if ! git worktree add "$WORKTREE_PATH" -b "$BRANCH_NAME"; then
    echo "Error: Failed to create worktree"
    # Clean up potentially created branch
    git branch -D "$BRANCH_NAME" 2>/dev/null || true
    rmdir "$TEMP_DIR" 2>/dev/null || true
    WORKTREE_PATH=""  # Prevent cleanup from running
    exit 1
fi

# 6. Spawn tmux
SESSION_NAME="worktree-$BRANCH_NAME-$$"

if [[ -n "${TMUX:-}" ]]; then
    # Already in tmux - create new window in current session
    # Save current window for returning later
    ORIGINAL_WINDOW=$(tmux display-message -p '#{window_id}')
    WAIT_CHANNEL="worktree-done-$$"

    # Create window that signals when shell exits
    tmux new-window -n "$BRANCH_NAME" -c "$WORKTREE_PATH" \
        "\$SHELL; tmux wait-for -S $WAIT_CHANNEL"

    # Wait for signal
    tmux wait-for "$WAIT_CHANNEL"

    # Return to original window for cleanup prompt
    tmux select-window -t "$ORIGINAL_WINDOW"
else
    # Not in tmux, create new session (blocking)
    tmux new-session -s "$SESSION_NAME" -c "$WORKTREE_PATH"
fi

# Cleanup runs via trap on EXIT
